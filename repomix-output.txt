This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-07-07T07:50:21.238Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

================================================================
Directory Structure
================================================================
.gitignore
package.json
src/main.js
src/preload.js
src/renderer.html
src/renderer.js
src/styles.css

================================================================
Files
================================================================

================
File: .gitignore
================
# Node.js
node_modules/
dist/
build/

# Logs
logs/
*.log
npm-debug.log*

# Dependency directories
pids/
*.pid
*.seed
*.pid.lock

# Optional npm cache directory
.npm/

# Optional eslint cache
.eslintcache

# Optional REPL history
.node_repl_history

# Environment variables
.env
.env.local
.env.development.local
.env.test.local
.env.production.local

# IDE-specific files
.idea/
.vscode/
*.swp
*.bak
*.swo

# Test coverage
coverage/

# Thumbnails
.DS_Store
Thumbs.db

================
File: package.json
================
{
  "name": "stealth-meeting-assistant",
  "version": "1.0.0",
  "description": "Invisible AI assistant for meetings - undetectable during screen share",
  "main": "src/main.js",
  "scripts": {
    "start": "electron .",
    "build": "electron-builder",
    "dev": "electron . --enable-logging"
  },
  "dependencies": {
    "electron": "^28.0.0",
    "@google/generative-ai": "^0.2.1",
    "screenshot-desktop": "^1.15.0",
    "dotenv": "^16.3.1",
    "node-window-manager": "^2.2.4"
  },
  "devDependencies": {
    "electron-builder": "^24.0.0"
  },
  "build": {
    "appId": "com.stealth.meetingassistant",
    "productName": "Meeting Assistant",
    "directories": {
      "output": "dist"
    },
    "files": [
      "src/**/*",
      "package.json",
      ".env"
    ],
    "mac": {
      "category": "public.app-category.productivity"
    },
    "win": {
      "target": "nsis"
    },
    "linux": {
      "target": "AppImage"
    }
  },
  "author": "Your Name",
  "license": "MIT"
}

================
File: src/main.js
================
const { app, BrowserWindow, globalShortcut, ipcMain, screen } = require('electron');
const path = require('path');
const fs = require('fs');
const screenshot = require('screenshot-desktop');
const { GoogleGenerativeAI } = require('@google/generative-ai');
require('dotenv').config();

let mainWindow;
let screenshots = [];
const MAX_SCREENSHOTS = 3;

// Initialize Gemini AI
const genAI = new GoogleGenerativeAI(process.env.GEMINI_API_KEY);
const model = genAI.getGenerativeModel({ model: "gemini-2.0-flash" });

function createStealthWindow() {
  console.log('Creating stealth window...');
  const { width, height } = screen.getPrimaryDisplay().workAreaSize;
  
  // Position at top center
  const windowWidth = 1920;
  const windowHeight = 1080;
  const x = Math.floor((width - windowWidth) / 2);
  const y = 20;
  
  console.log(`Window position: ${x}, ${y}`);
  
  mainWindow = new BrowserWindow({
    width: windowWidth,
    height: windowHeight,
    x: x,
    y: y,
    webPreferences: {
      nodeIntegration: false,
      contextIsolation: true,
      preload: path.join(__dirname, 'preload.js'),
      backgroundThrottling: false,
      offscreen: false
    },
    frame: false,
    transparent: true,
    alwaysOnTop: true,
    skipTaskbar: true,
    resizable: false,
    minimizable: false,
    maximizable: false,
    closable: false,
    focusable: false,
    show: true,
    opacity: 0.95, // Make it more visible
    type: 'toolbar',
    acceptFirstMouse: false,
    disableAutoHideCursor: true,
    enableLargerThanScreen: false,
    hasShadow: false,
    thickFrame: false,
    titleBarStyle: 'hidden',
    webSecurity: false,
    experimentalFeatures: true
  });

  console.log('BrowserWindow created');
  
  const htmlPath = path.join(__dirname, 'renderer.html');
  mainWindow.loadFile(htmlPath);
  
  // Apply stealth settings
  if (process.platform === 'darwin') {
    mainWindow.setVisibleOnAllWorkspaces(true, { 
      visibleOnFullScreen: true,
      skipTransformProcessType: true 
    });
    mainWindow.setAlwaysOnTop(true, 'pop-up-menu', 1);
    app.dock.hide();
    mainWindow.setHiddenInMissionControl(true);
  } else if (process.platform === 'win32') {
    console.log('Applying Windows stealth settings');
    mainWindow.setSkipTaskbar(true);
    mainWindow.setAlwaysOnTop(true, 'pop-up-menu');
    mainWindow.setAppDetails({
      appId: 'SystemProcess',
      appIconPath: '',
      relaunchCommand: '',
      relaunchDisplayName: ''
    });
  } else if (process.platform === 'linux') {
    mainWindow.setSkipTaskbar(true);
    if (mainWindow.setHasShadow) {
      mainWindow.setHasShadow(false);
    }
  }
  
  // REMOVE CONTENT PROTECTION TEMPORARILY TO TEST
  // mainWindow.setContentProtection(true);
  console.log('Skipping content protection for testing...');
  
  mainWindow.setIgnoreMouseEvents(false);
  
  // Wait for DOM to be ready, then apply CSS
  mainWindow.webContents.on('dom-ready', () => {
    console.log('DOM is ready, applying CSS...');
    
    mainWindow.webContents.insertCSS(`
      body {
        -webkit-app-region: no-drag;
        background: rgba(255, 255, 255, 0.95) !important;
        color: black !important;
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif !important;
      }
      
      * {
        color: black !important;
      }
      
      .glass-container {
        background: rgba(255, 255, 255, 0.95) !important;
        color: black !important;
      }
    `).then(() => {
      console.log('CSS applied successfully');
    }).catch((error) => {
      console.log('CSS application failed:', error);
    });
  });
  
  mainWindow.webContents.on('did-finish-load', () => {
    console.log('HTML finished loading');
    
    // Execute JavaScript to check content
    mainWindow.webContents.executeJavaScript(`
      console.log('JavaScript executing...');
      console.log('Document title:', document.title);
      console.log('Body exists:', !!document.body);
      console.log('App element exists:', !!document.getElementById('app'));
      console.log('Glass container exists:', !!document.querySelector('.glass-container'));
      
      // Force visibility
      if (document.body) {
        document.body.style.background = 'rgba(255, 255, 255, 0.95)';
        document.body.style.color = 'black';
        document.body.style.visibility = 'visible';
        document.body.style.display = 'block';
      }
      
      const app = document.getElementById('app');
      if (app) {
        app.style.background = 'rgba(255, 255, 255, 0.95)';
        app.style.color = 'black';
        app.style.visibility = 'visible';
        app.style.display = 'block';
      }
      
      'Content forced visible';
    `).then((result) => {
      console.log('JavaScript result:', result);
    }).catch((error) => {
      console.log('JavaScript execution failed:', error);
    });
  });
  
  // NO DEV TOOLS - This was covering your interface!
}

function registerStealthShortcuts() {
  globalShortcut.register('CommandOrControl+Alt+Shift+H', () => {
    toggleStealthMode();
  });

  globalShortcut.register('CommandOrControl+Alt+Shift+S', async () => {
    await takeStealthScreenshot();
  });

  globalShortcut.register('CommandOrControl+Alt+Shift+A', async () => {
    if (screenshots.length > 0) {
      await analyzeForMeeting();
    }
  });

  globalShortcut.register('CommandOrControl+Alt+Shift+X', () => {
    emergencyHide();
  });

  globalShortcut.register('CommandOrControl+Alt+Shift+Left', () => {
    moveToPosition('left');
  });
  
  globalShortcut.register('CommandOrControl+Alt+Shift+Right', () => {
    moveToPosition('right');
  });
  
  globalShortcut.register('CommandOrControl+Alt+Shift+Up', () => {
    moveToPosition('top');
  });
  
  globalShortcut.register('CommandOrControl+Alt+Shift+Down', () => {
    moveToPosition('bottom');
  });
}

let isVisible = true;
let autoHideTimer = null;

function toggleStealthMode() {
  if (autoHideTimer) {
    clearTimeout(autoHideTimer);
    autoHideTimer = null;
  }

  if (isVisible) {
    mainWindow.setOpacity(0.6);
    mainWindow.webContents.send('set-stealth-mode', true);
    isVisible = false;
  } else {
    mainWindow.setOpacity(0.95);
    mainWindow.webContents.send('set-stealth-mode', false);
    isVisible = true;
  }
}

function emergencyHide() {
  if (autoHideTimer) {
    clearTimeout(autoHideTimer);
    autoHideTimer = null;
  }

  mainWindow.setOpacity(0.1);
  mainWindow.webContents.send('emergency-clear');
  
  autoHideTimer = setTimeout(() => {
    if (mainWindow && !mainWindow.isDestroyed()) {
      mainWindow.setOpacity(0.95);
      isVisible = true;
    }
    autoHideTimer = null;
  }, 2000);
}

function moveToPosition(position) {
  const { width, height } = screen.getPrimaryDisplay().workAreaSize;
  const windowBounds = mainWindow.getBounds();
  
  let x, y;
  
  switch (position) {
    case 'left':
      x = 20;
      y = windowBounds.y;
      break;
    case 'right':
      x = width - windowBounds.width - 20;
      y = windowBounds.y;
      break;
    case 'top':
      x = Math.floor((width - windowBounds.width) / 2);
      y = 20;
      break;
    case 'bottom':
      x = Math.floor((width - windowBounds.width) / 2);
      y = height - windowBounds.height - 20;
      break;
    default:
      return;
  }
  
  mainWindow.setPosition(x, y);
}

async function takeStealthScreenshot() {
  try {
    const currentOpacity = mainWindow.getOpacity();
    
    mainWindow.setOpacity(0.1);
    
    await new Promise(resolve => setTimeout(resolve, 200));
    
    const screenshotsDir = path.join(__dirname, '..', '.stealth_screenshots');
    if (!fs.existsSync(screenshotsDir)) {
      fs.mkdirSync(screenshotsDir, { recursive: true });
    }
    
    const screenshotPath = path.join(screenshotsDir, `stealth-${Date.now()}.png`);
    await screenshot({ filename: screenshotPath });
    
    screenshots.push(screenshotPath);
    if (screenshots.length > MAX_SCREENSHOTS) {
      const oldPath = screenshots.shift();
      if (fs.existsSync(oldPath)) {
        fs.unlinkSync(oldPath);
      }
    }
    
    mainWindow.setOpacity(currentOpacity);
    
    mainWindow.webContents.send('screenshot-taken-stealth', screenshots.length);
    
    return screenshotPath;
  } catch (error) {
    mainWindow.setOpacity(0.95);
    console.error('Stealth screenshot error:', error);
    throw error;
  }
}

async function analyzeForMeeting() {
  if (!process.env.GEMINI_API_KEY) {
    mainWindow.webContents.send('analysis-result', {
      error: 'No API key configured'
    });
    return;
  }

  try {
    mainWindow.webContents.send('analysis-start');
    
    const imageParts = await Promise.all(
      screenshots.map(async (path) => {
        const imageData = fs.readFileSync(path);
        return {
          inlineData: {
            data: imageData.toString('base64'),
            mimeType: 'image/png'
          }
        };
      })
    );

    const prompt = `You are an expert coding assistant for technical interviews and meetings. Analyze these screenshots and respond in this EXACT format:

**CODE SOLUTION:**
\`\`\`[language]
[Your complete, working code solution here]
\`\`\`

**LOGIC EXPLANATION:**
[Brief explanation of the approach and complexity]

**KEY POINTS:**
â€¢ [Important insight 1]
â€¢ [Important insight 2]
â€¢ [Important insight 3]

Rules:
1. ALWAYS provide code first, explanation second
2. Use the most efficient solution
3. Include time/space complexity
4. Be concise but complete
5. If it's not a coding problem, provide direct, actionable answers
6. Focus on what will impress in a technical interview

Analyze the screenshots and provide the solution:`;

    const result = await model.generateContent([prompt, ...imageParts]);
    const response = await result.response;
    const text = response.text();

    mainWindow.webContents.send('analysis-result', { text });
  } catch (error) {
    console.error('Analysis error:', error);
    mainWindow.webContents.send('analysis-result', {
      error: 'Analysis failed'
    });
  }
}

// IPC handlers
ipcMain.handle('get-screenshots-count', () => screenshots.length);
ipcMain.handle('toggle-stealth', () => toggleStealthMode());
ipcMain.handle('emergency-hide', () => emergencyHide());
ipcMain.handle('take-stealth-screenshot', () => takeStealthScreenshot());
ipcMain.handle('analyze-stealth', () => analyzeForMeeting());
ipcMain.handle('clear-stealth', () => {
  screenshots.forEach(path => {
    if (fs.existsSync(path)) fs.unlinkSync(path);
  });
  screenshots = [];
  return { success: true };
});

// App event handlers
app.whenReady().then(() => {
  console.log('App is ready, creating window...');
  createStealthWindow();
  registerStealthShortcuts();
  
  mainWindow.setOpacity(0.95);
  mainWindow.setIgnoreMouseEvents(false);
  mainWindow.show();
  isVisible = true;
  
  console.log('Window setup complete');
});

app.on('window-all-closed', () => {
  // Keep running in background
});

app.on('activate', () => {
  if (BrowserWindow.getAllWindows().length === 0) {
    createStealthWindow();
  }
});

app.on('will-quit', () => {
  globalShortcut.unregisterAll();
  
  screenshots.forEach(path => {
    if (fs.existsSync(path)) fs.unlinkSync(path);
  });
});

app.on('web-contents-created', (event, contents) => {
  contents.on('new-window', (event, navigationUrl) => {
    event.preventDefault();
  });
  
  contents.on('will-navigate', (event, navigationUrl) => {
    if (navigationUrl !== mainWindow.webContents.getURL()) {
      event.preventDefault();
    }
  });
});

process.title = 'SystemIdleProcess';

================
File: src/preload.js
================
const { contextBridge, ipcRenderer } = require('electron');

// Expose stealth API to renderer process
contextBridge.exposeInMainWorld('electronAPI', {
  // Core stealth actions
  toggleStealth: () => ipcRenderer.invoke('toggle-stealth'),
  emergencyHide: () => ipcRenderer.invoke('emergency-hide'),
  takeStealthScreenshot: () => ipcRenderer.invoke('take-stealth-screenshot'),
  analyzeStealth: () => ipcRenderer.invoke('analyze-stealth'),
  clearStealth: () => ipcRenderer.invoke('clear-stealth'),
  getScreenshotsCount: () => ipcRenderer.invoke('get-screenshots-count'),
  
  // Event listeners with cleanup functions
  onScreenshotTakenStealth: (callback) => {
    const handler = (event, count) => callback(count);
    ipcRenderer.on('screenshot-taken-stealth', handler);
    return () => ipcRenderer.removeListener('screenshot-taken-stealth', handler);
  },
  
  onAnalysisStart: (callback) => {
    const handler = () => callback();
    ipcRenderer.on('analysis-start', handler);
    return () => ipcRenderer.removeListener('analysis-start', handler);
  },
  
  onAnalysisResult: (callback) => {
    const handler = (event, data) => callback(data);
    ipcRenderer.on('analysis-result', handler);
    return () => ipcRenderer.removeListener('analysis-result', handler);
  },
  
  onSetStealthMode: (callback) => {
    const handler = (event, enabled) => callback(enabled);
    ipcRenderer.on('set-stealth-mode', handler);
    return () => ipcRenderer.removeListener('set-stealth-mode', handler);
  },
  
  onEmergencyClear: (callback) => {
    const handler = () => callback();
    ipcRenderer.on('emergency-clear', handler);
    return () => ipcRenderer.removeListener('emergency-clear', handler);
  },
  
  onError: (callback) => {
    const handler = (event, message) => callback(message);
    ipcRenderer.on('error', handler);
    return () => ipcRenderer.removeListener('error', handler);
  }
});

================
File: src/renderer.html
================
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>AI Assistant</title>
  <link rel="stylesheet" href="styles.css">
</head>
<body>
  <div id="app" class="cluely-container">
    <!-- Main Interface - Cluely Style -->
    <div class="main-interface">
      <!-- Status Indicator and Timer -->
      <div class="status-section">
        <div class="status-dot"></div>
        <span class="timer">00:00</span>
        <div class="screenshot-count" id="screenshot-count">0</div>
      </div>
      
      <!-- Main Content Area -->
      <div class="content-section">
        <div class="ai-status">
          <span class="ai-icon">ðŸ¤–</span>
          <span id="status-text" class="status-text">AI Assistant</span>
        </div>
        
        <!-- Action Buttons -->
        <div class="action-buttons">
          <button id="screenshot-btn" class="action-btn screenshot-btn" title="Screenshot (Ctrl+Alt+Shift+S)">
            <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor">
              <path d="M9 2 7.17 4H4c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V6c0-1.1-.9-2-2-2h-3.17L15 2H9zm3 15c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5z"/>
            </svg>
          </button>
          
          <button id="analyze-btn" class="action-btn analyze-btn" title="Ask AI (Ctrl+Alt+Shift+A)">
            Ask AI
          </button>
          
          <button id="clear-btn" class="action-btn clear-btn" title="Clear">
            <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor">
              <path d="M6 19c0 1.1.9 2 2 2h8c1.1 0 2-.9 2-2V7H6v12zM19 4h-3.5l-1-1h-5l-1 1H5v2h14V4z"/>
            </svg>
          </button>
          
          <button id="hide-btn" class="action-btn hide-btn" title="Show/Hide (Ctrl+Alt+Shift+X)">
            <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor">
              <path d="M18.3 5.71a1 1 0 0 0-1.41 0L12 10.59 7.11 5.7a1 1 0 1 0-1.42 1.42L10.59 12l-4.9 4.89a1 1 0 0 0 1.42 1.42L12 13.41l4.89 4.9a1 1 0 0 0 1.42-1.42L13.41 12l4.9-4.89a1 1 0 0 0 0-1.4Z"/>
            </svg>
          </button>
        </div>
      </div>
      
      <!-- Settings Icon -->
      <div class="settings-section">
        <button class="settings-btn" title="Settings">
          <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor">
            <path d="M19.14,12.94c0.04-0.3,0.06-0.61,0.06-0.94c0-0.32-0.02-0.64-0.07-0.94l2.03-1.58c0.18-0.14,0.23-0.41,0.12-0.61 l-1.92-3.32c-0.12-0.22-0.37-0.29-0.59-0.22l-2.39,0.96c-0.5-0.38-1.03-0.7-1.62-0.94L14.4,2.81c-0.04-0.24-0.24-0.41-0.48-0.41 h-3.84c-0.24,0-0.43,0.17-0.47,0.41L9.25,5.35C8.66,5.59,8.12,5.92,7.63,6.29L5.24,5.33c-0.22-0.08-0.47,0-0.59,0.22L2.74,8.87 C2.62,9.08,2.66,9.34,2.86,9.48l2.03,1.58C4.84,11.36,4.8,11.69,4.8,12s0.02,0.64,0.07,0.94l-2.03,1.58 c-0.18,0.14-0.23,0.41-0.12,0.61l1.92,3.32c0.12,0.22,0.37,0.29,0.59,0.22l2.39-0.96c0.5,0.38,1.03,0.7,1.62,0.94l0.36,2.54 c0.05,0.24,0.24,0.41,0.48,0.41h3.84c0.24,0,0.44-0.17,0.47-0.41l0.36-2.54c0.59-0.24,1.13-0.56,1.62-0.94l2.39,0.96 c0.22,0.08,0.47,0,0.59-0.22l1.92-3.32c0.12-0.22,0.07-0.47-0.12-0.61L19.14,12.94z M12,15.6c-1.98,0-3.6-1.62-3.6-3.6 s1.62-3.6,3.6-3.6s3.6,1.62,3.6,3.6S13.98,15.6,12,15.6z"/>
          </svg>
        </button>
      </div>
    </div>
    
    <!-- Expandable Results Panel -->
    <div id="results-panel" class="results-panel hidden">
      <div class="results-header">
        <div class="results-title">
          <span class="ai-response-icon">âœ¨</span>
          <span>AI Response</span>
        </div>
        <div class="results-actions">
          <button id="copy-btn" class="copy-btn" title="Copy">
            <svg width="14" height="14" viewBox="0 0 24 24" fill="currentColor">
              <path d="M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12V1zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2zm0 16H8V7h11v14z"/>
            </svg>
          </button>
          <button id="close-results" class="close-btn" title="Close">
            <svg width="14" height="14" viewBox="0 0 24 24" fill="currentColor">
              <path d="M18.3 5.71a1 1 0 0 0-1.41 0L12 10.59 7.11 5.7a1 1 0 1 0-1.42 1.42L10.59 12l-4.9 4.89a1 1 0 0 0 1.42 1.42L12 13.41l4.89 4.9a1 1 0 0 0 1.42-1.42L13.41 12l4.9-4.89a1 1 0 0 0 0-1.4Z"/>
            </svg>
          </button>
        </div>
      </div>
      <div class="results-content">
        <div id="result-text" class="result-text"></div>
      </div>
    </div>
    
    <!-- Loading Overlay -->
    <div id="loading-overlay" class="loading-overlay hidden">
      <div class="loading-content">
        <div class="analyzing-icon">ðŸ§ </div>
        <div class="loading-text">Analyzing screen...</div>
      </div>
    </div>
    
    <!-- Emergency Overlay -->
    <div id="emergency-overlay" class="emergency-overlay hidden">
      <div class="emergency-message">HIDDEN</div>
    </div>
  </div>

  <script src="renderer.js"></script>
</body>
</html>

================
File: src/renderer.js
================
// CLUELY-STYLE STEALTH MEETING ASSISTANT
let screenshotsCount = 0;
let isAnalyzing = false;
let stealthModeActive = false;
let stealthHideTimeout = null;

// DOM elements
const statusText = document.getElementById('status-text');
const screenshotCount = document.getElementById('screenshot-count');
const resultsPanel = document.getElementById('results-panel');
const resultText = document.getElementById('result-text');
const loadingOverlay = document.getElementById('loading-overlay');
const emergencyOverlay = document.getElementById('emergency-overlay');

const screenshotBtn = document.getElementById('screenshot-btn');
const analyzeBtn = document.getElementById('analyze-btn');
const clearBtn = document.getElementById('clear-btn');
const hideBtn = document.getElementById('hide-btn');
const copyBtn = document.getElementById('copy-btn');
const closeResultsBtn = document.getElementById('close-results');

// Timer for Cluely-style display
let startTime = Date.now();
let timerInterval;

// Initialize
function init() {
  setupEventListeners();
  setupIpcListeners();
  updateUI();
  startTimer();
  stealthModeActive = false;
}

// Start the timer display
function startTimer() {
  const timerElement = document.querySelector('.timer');
  timerInterval = setInterval(() => {
    const elapsed = Math.floor((Date.now() - startTime) / 1000);
    const minutes = Math.floor(elapsed / 60).toString().padStart(2, '0');
    const seconds = (elapsed % 60).toString().padStart(2, '0');
    timerElement.textContent = `${minutes}:${seconds}`;
  }, 1000);
}

// Setup event listeners
function setupEventListeners() {
  // Button events
  screenshotBtn.addEventListener('click', takeStealthScreenshot);
  analyzeBtn.addEventListener('click', analyzeScreenshots);
  clearBtn.addEventListener('click', clearStealthData);
  hideBtn.addEventListener('click', emergencyHide);
  copyBtn.addEventListener('click', copyToClipboard);
  closeResultsBtn.addEventListener('click', hideResults);

  // Keyboard shortcuts
  document.addEventListener('keydown', (e) => {
    if (e.ctrlKey && e.altKey && e.shiftKey) {
      switch (e.key.toLowerCase()) {
        case 'h':
          e.preventDefault();
          window.electronAPI.toggleStealth();
          break;
        case 's':
          e.preventDefault();
          takeStealthScreenshot();
          break;
        case 'a':
          e.preventDefault();
          analyzeScreenshots();
          break;
        case 'x':
          e.preventDefault();
          emergencyHide();
          break;
      }
    }
  });

  // Prevent context menu and selection
  document.addEventListener('contextmenu', e => e.preventDefault());
  document.addEventListener('selectstart', e => e.preventDefault());
  document.addEventListener('dragstart', e => e.preventDefault());
}

// Setup IPC listeners
function setupIpcListeners() {
  // Screenshot taken
  window.electronAPI.onScreenshotTakenStealth((count) => {
    screenshotsCount = count;
    updateUI();
    showFeedback('Screenshot captured', 'success');
  });

  // Analysis events
  window.electronAPI.onAnalysisStart(() => {
    setAnalyzing(true);
    showLoadingOverlay();
  });

  window.electronAPI.onAnalysisResult((data) => {
    setAnalyzing(false);
    hideLoadingOverlay();
    
    if (data.error) {
      showFeedback(data.error, 'error');
    } else {
      showResults(data.text);
      showFeedback('Analysis complete', 'success');
    }
  });

  // Stealth mode events
  window.electronAPI.onSetStealthMode((enabled) => {
    setStealthMode(enabled);
  });

  // Emergency events
  window.electronAPI.onEmergencyClear(() => {
    hideResults();
    clearStealthData();
    emergencyHide();
  });

  // Error handling
  window.electronAPI.onError((message) => {
    showFeedback(message, 'error');
  });
}

// Take screenshot
async function takeStealthScreenshot() {
  try {
    screenshotBtn.disabled = true;
    await window.electronAPI.takeStealthScreenshot();
  } catch (error) {
    showFeedback('Screenshot failed', 'error');
  } finally {
    screenshotBtn.disabled = false;
  }
}

// Analyze screenshots
async function analyzeScreenshots() {
  if (screenshotsCount === 0) {
    showFeedback('No screenshots to analyze', 'error');
    return;
  }

  try {
    await window.electronAPI.analyzeStealth();
  } catch (error) {
    showFeedback('Analysis failed', 'error');
  }
}

// Clear data
async function clearStealthData() {
  try {
    clearBtn.disabled = true;
    const result = await window.electronAPI.clearStealth();
    
    if (result.success) {
      screenshotsCount = 0;
      hideResults();
      updateUI();
      showFeedback('Data cleared', 'info');
    }
  } catch (error) {
    showFeedback('Clear failed', 'error');
  } finally {
    clearBtn.disabled = false;
  }
}

// Emergency hide
function emergencyHide() {
  emergencyOverlay.classList.remove('hidden');
  
  // Clear sensitive content
  resultText.textContent = '';
  
  // Auto-restore after 2 seconds
  setTimeout(() => {
    emergencyOverlay.classList.add('hidden');
  }, 2000);
}

// Show results
function showResults(text) {
  if (!text) return;
  
  const formattedText = formatResponse(text);
  resultText.innerHTML = formattedText;
  resultsPanel.classList.remove('hidden');
}

// Hide results
function hideResults() {
  resultsPanel.classList.add('hidden');
  resultText.innerHTML = '';
}

// Format AI response
function formatResponse(text) {
  let formatted = text;
  
  // Format code blocks
  formatted = formatted.replace(
    /```(\w+)?\n([\s\S]*?)```/g,
    '<div class="code-block"><code>$2</code></div>'
  );
  
  // Format inline code
  formatted = formatted.replace(/`([^`]+)`/g, '<code>$1</code>');
  
  // Format sections
  formatted = formatted.replace(
    /\*\*LOGIC EXPLANATION:\*\*([\s\S]*?)(?=\*\*|$)/g,
    '<div class="logic-section"><strong>LOGIC EXPLANATION:</strong>$1</div>'
  );
  
  formatted = formatted.replace(
    /\*\*KEY POINTS:\*\*([\s\S]*?)(?=\*\*|$)/g,
    '<div class="key-points"><strong>KEY POINTS:</strong>$1</div>'
  );
  
  // Format bold text
  formatted = formatted.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>');
  
  // Format bullet points
  formatted = formatted.replace(/â€¢ (.*?)(?=\n|$)/g, '<div>â€¢ $1</div>');
  
  // Format line breaks
  formatted = formatted.replace(/\n/g, '<br>');
  
  return formatted;
}

// Copy to clipboard
async function copyToClipboard() {
  try {
    const text = resultText.textContent;
    await navigator.clipboard.writeText(text);
    showFeedback('Copied to clipboard', 'success');
  } catch (error) {
    showFeedback('Copy failed', 'error');
  }
}

// Update UI
function updateUI() {
  // Update screenshot counter
  screenshotCount.textContent = screenshotsCount;
  
  // Update button states
  analyzeBtn.disabled = screenshotsCount === 0 || isAnalyzing;
  clearBtn.disabled = screenshotsCount === 0;
  
  // Update status text
  if (isAnalyzing) {
    statusText.textContent = 'Analyzing...';
  } else if (screenshotsCount === 0) {
    statusText.textContent = 'AI Assistant';
  } else {
    statusText.textContent = `${screenshotsCount} screenshot${screenshotsCount > 1 ? 's' : ''} ready`;
  }
}

// Set analyzing state
function setAnalyzing(analyzing) {
  isAnalyzing = analyzing;
  updateUI();
}

// Stealth mode management
function setStealthMode(enabled) {
  if (stealthHideTimeout) {
    clearTimeout(stealthHideTimeout);
    stealthHideTimeout = null;
  }

  stealthModeActive = enabled;
  
  if (enabled) {
    document.body.classList.add('stealth-mode');
  } else {
    document.body.classList.remove('stealth-mode');
  }
}

// Loading overlay
function showLoadingOverlay() {
  loadingOverlay.classList.remove('hidden');
}

function hideLoadingOverlay() {
  loadingOverlay.classList.add('hidden');
}

// Feedback system
function showFeedback(message, type = 'info') {
  const originalStatus = statusText.textContent;
  
  statusText.textContent = message;
  statusText.className = `status-text status-${type}`;
  
  // Revert after 2 seconds
  setTimeout(() => {
    statusText.textContent = originalStatus;
    statusText.className = 'status-text';
    updateUI();
  }, 2000);
}

// Initialize when DOM is ready
document.addEventListener('DOMContentLoaded', () => {
  init();
  
  // Start in normal visible mode
  stealthModeActive = false;
});

// Cleanup
window.addEventListener('beforeunload', () => {
  if (timerInterval) {
    clearInterval(timerInterval);
  }
  if (stealthHideTimeout) {
    clearTimeout(stealthHideTimeout);
  }
});

================
File: src/styles.css
================
/* FIXED CSS - KEEPS YOUR WORKING STYLE WITH CLUELY IMPROVEMENTS */

* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
  -webkit-user-select: none;
  user-select: none;
}

body {
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
  background: transparent;
  color: rgba(255, 255, 255, 0.9);
  overflow: hidden;
  cursor: default;
  font-size: 11px;
  line-height: 1.3;
}

/* MAIN GLASS CONTAINER - YOUR WORKING VERSION WITH CLUELY COLORS */
.glass-container {
  width: 100vw;
  height: 100vh;
  background: rgba(255, 255, 255, 0.95);
  backdrop-filter: blur(20px) saturate(1.8);
  -webkit-backdrop-filter: blur(20px) saturate(1.8);
  border: 1px solid rgba(0, 0, 0, 0.1);
  border-radius: 16px;
  padding: 8px;
  position: relative;
  
  /* Cluely-style shadow */
  box-shadow: 
    0 8px 32px rgba(0, 0, 0, 0.15),
    inset 0 1px 0 rgba(255, 255, 255, 0.3);
  
  -webkit-app-region: no-drag;
  opacity: 1;
  transition: opacity 0.3s ease-in-out;
}

/* KEEP YOUR EXACT STEALTH MODE LOGIC */
.stealth-mode .glass-container {
  background: rgba(20, 25, 35, 0.7);
  border: 1px solid rgba(255, 255, 255, 0.15);
  opacity: 0.8;
  transition: all 0.5s ease;
}

.stealth-mode * {
  opacity: 0.9 !important;
  transition: opacity 0.5s ease;
}

.stealth-mode:hover * {
  opacity: 1 !important;
  transition: opacity 0.2s ease;
}

/* HEADER - IMPROVED VISIBILITY */
.header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 8px;
  padding: 4px 6px;
  background: rgba(0, 0, 0, 0.1);
  border-radius: 8px;
  border: 1px solid rgba(0, 0, 0, 0.15);
}

.status-indicator {
  display: flex;
  align-items: center;
  gap: 4px;
  font-size: 9px;
  color: rgba(0, 0, 0, 0.8);
  font-weight: 500;
}

.pulse-dot {
  width: 6px;
  height: 6px;
  background: #00ff88;
  border-radius: 50%;
  animation: pulse 2s infinite;
}

@keyframes pulse {
  0%, 100% { opacity: 1; transform: scale(1); }
  50% { opacity: 0.5; transform: scale(1.2); }
}

.quick-actions {
  display: flex;
  gap: 2px;
}

.ghost-btn {
  background: rgba(0, 0, 0, 0.1);
  border: 1px solid rgba(0, 0, 0, 0.2);
  color: rgba(0, 0, 0, 0.7);
  width: 18px;
  height: 18px;
  border-radius: 4px;
  font-size: 10px;
  cursor: pointer;
  transition: all 0.2s ease;
  display: flex;
  align-items: center;
  justify-content: center;
}

.ghost-btn:hover {
  background: rgba(255, 0, 0, 0.2);
  color: rgba(0, 0, 0, 0.9);
  transform: scale(1.1);
}

/* CONTENT */
.content {
  display: flex;
  flex-direction: column;
  gap: 6px;
  height: calc(100% - 40px);
}

/* SCREENSHOT COUNTER - IMPROVED VISIBILITY */
.count-badge {
  position: absolute;
  top: 8px;
  right: 8px;
  background: #3b82f6;
  border: 1px solid rgba(59, 130, 246, 0.5);
  color: white;
  padding: 2px 6px;
  border-radius: 10px;
  font-size: 9px;
  font-weight: 600;
  backdrop-filter: blur(10px);
  min-width: 16px;
  text-align: center;
}

/* RESULTS AREA - IMPROVED VISIBILITY */
.result-glass {
  background: rgba(0, 0, 0, 0.1);
  border: 1px solid rgba(0, 0, 0, 0.2);
  border-radius: 12px;
  padding: 8px;
  backdrop-filter: blur(25px) saturate(2);
  -webkit-backdrop-filter: blur(25px) saturate(2);
  max-height: 120px;
  overflow-y: auto;
  position: relative;
  
  box-shadow: 
    0 4px 16px rgba(0, 0, 0, 0.1),
    inset 0 1px 0 rgba(255, 255, 255, 0.1);
}

.result-glass.hidden {
  display: none;
}

.result-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 6px;
  padding-bottom: 4px;
  border-bottom: 1px solid rgba(0, 0, 0, 0.1);
}

.result-type {
  font-size: 9px;
  color: rgba(0, 0, 0, 0.8);
  font-weight: 600;
}

.copy-btn {
  background: rgba(0, 0, 0, 0.1);
  border: 1px solid rgba(0, 0, 0, 0.2);
  color: rgba(0, 0, 0, 0.7);
  padding: 2px 4px;
  border-radius: 4px;
  font-size: 8px;
  cursor: pointer;
  transition: all 0.2s ease;
}

.copy-btn:hover {
  background: rgba(0, 255, 0, 0.2);
  color: rgba(0, 0, 0, 0.9);
}

.result-content {
  font-size: 9px;
  line-height: 1.4;
  color: rgba(0, 0, 0, 0.8);
}

.result-content pre {
  white-space: pre-wrap;
  word-wrap: break-word;
  font-family: 'SF Mono', Monaco, Consolas, monospace;
  background: rgba(0, 0, 0, 0.2);
  padding: 4px;
  border-radius: 4px;
  border: 1px solid rgba(0, 0, 0, 0.1);
  color: rgba(0, 0, 0, 0.9);
}

/* STEALTH CONTROLS - IMPROVED VISIBILITY */
.stealth-controls {
  display: flex;
  gap: 4px;
  justify-content: center;
  padding: 4px;
  background: rgba(0, 0, 0, 0.1);
  border-radius: 10px;
  border: 1px solid rgba(0, 0, 0, 0.15);
}

.stealth-btn {
  background: rgba(0, 0, 0, 0.1);
  border: 1px solid rgba(0, 0, 0, 0.2);
  color: rgba(0, 0, 0, 0.8);
  padding: 4px 8px;
  border-radius: 6px;
  font-size: 10px;
  cursor: pointer;
  transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
  backdrop-filter: blur(10px);
  min-width: 24px;
  height: 24px;
  display: flex;
  align-items: center;
  justify-content: center;
}

.stealth-btn:hover {
  background: rgba(0, 0, 0, 0.2);
  color: rgba(0, 0, 0, 0.9);
  transform: translateY(-1px);
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
}

.stealth-btn.primary {
  background: #3b82f6;
  border-color: rgba(59, 130, 246, 0.6);
  color: white;
}

.stealth-btn.primary:hover {
  background: #2563eb;
  box-shadow: 0 2px 12px rgba(59, 130, 246, 0.4);
}

.stealth-btn.danger {
  background: rgba(0, 0, 0, 0.1);
  border-color: rgba(0, 0, 0, 0.2);
}

.stealth-btn.danger:hover {
  background: rgba(255, 0, 0, 0.2);
  color: rgba(0, 0, 0, 0.9);
}

.stealth-btn:disabled {
  opacity: 0.3;
  cursor: not-allowed;
  transform: none;
}

/* KEEP YOUR EXACT EMERGENCY OVERLAY */
.emergency-overlay {
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: rgba(0, 0, 0, 0.9);
  display: flex;
  align-items: center;
  justify-content: center;
  border-radius: 16px;
  backdrop-filter: blur(40px);
}

.emergency-overlay.hidden {
  display: none;
}

.emergency-message {
  color: #ff4444;
  font-weight: 700;
  font-size: 12px;
  animation: blink 1s infinite;
}

@keyframes blink {
  0%, 50% { opacity: 1; }
  51%, 100% { opacity: 0.3; }
}

/* LOADING OVERLAY */
.loading-overlay {
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: rgba(255, 255, 255, 0.9);
  backdrop-filter: blur(30px);
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  border-radius: 16px;
}

.loading-overlay.hidden {
  display: none;
}

.loading-spinner {
  width: 16px;
  height: 16px;
  border: 2px solid rgba(0, 0, 0, 0.2);
  border-top: 2px solid #3b82f6;
  border-radius: 50%;
  animation: spin 1s linear infinite;
  margin-bottom: 8px;
}

.loading-text {
  font-size: 9px;
  color: rgba(0, 0, 0, 0.7);
  font-weight: 500;
}

@keyframes spin {
  0% { transform: rotate(0deg); }
  100% { transform: rotate(360deg); }
}

/* POSITION INDICATORS */
.position-indicators {
  position: absolute;
  bottom: 8px;
  left: 50%;
  transform: translateX(-50%);
  background: rgba(0, 0, 0, 0.6);
  padding: 4px 8px;
  border-radius: 8px;
  font-size: 8px;
  color: rgba(255, 255, 255, 0.8);
  backdrop-filter: blur(15px);
  border: 1px solid rgba(255, 255, 255, 0.1);
}

.position-indicators.hidden {
  display: none;
}

.position-hint {
  text-align: center;
  white-space: nowrap;
}

/* SCROLLBAR STYLING */
.result-content::-webkit-scrollbar {
  width: 3px;
}

.result-content::-webkit-scrollbar-track {
  background: rgba(0, 0, 0, 0.05);
  border-radius: 2px;
}

.result-content::-webkit-scrollbar-thumb {
  background: rgba(0, 0, 0, 0.2);
  border-radius: 2px;
}

.result-content::-webkit-scrollbar-thumb:hover {
  background: rgba(0, 0, 0, 0.3);
}

/* CODE HIGHLIGHTING */
.result-content code {
  color: #00ff88;
  background: rgba(0, 255, 136, 0.1);
  padding: 1px 3px;
  border-radius: 3px;
  font-size: 8px;
}

.result-content .code-block {
  background: rgba(0, 0, 0, 0.4);
  border: 1px solid rgba(255, 255, 255, 0.1);
  border-radius: 6px;
  padding: 6px;
  margin: 4px 0;
  font-family: 'SF Mono', Monaco, Consolas, monospace;
  font-size: 8px;
  line-height: 1.3;
  overflow-x: auto;
}

.result-content .logic-section {
  background: rgba(74, 144, 226, 0.1);
  border-left: 3px solid rgba(74, 144, 226, 0.5);
  padding: 4px 6px;
  margin: 4px 0;
  border-radius: 0 4px 4px 0;
}

.result-content .key-points {
  background: rgba(255, 215, 0, 0.1);
  border-left: 3px solid rgba(255, 215, 0, 0.5);
  padding: 4px 6px;
  margin: 4px 0;
  border-radius: 0 4px 4px 0;
}

/* STATUS STYLES */
.status-success { color: #00ff88; }
.status-error { color: #ff6b6b; }
.status-info { color: #74b9ff; }

/* RESPONSIVE ADJUSTMENTS */
@media (max-width: 400px) {
  .glass-container {
    padding: 6px;
  }
  
  .stealth-controls {
    flex-direction: column;
    gap: 2px;
  }
  
  .stealth-btn {
    width: 100%;
    min-width: auto;
  }
}

/* KEEP YOUR SCREEN RECORDING HIDING */
@media screen and (max-resolution: 1dppx) {
  body {
    opacity: 0 !important;
    visibility: hidden !important;
  }
}

/* ADDITIONAL STEALTH MEASURES */
.glass-container::before {
  content: '';
  position: absolute;
  top: -1px;
  left: -1px;
  right: -1px;
  bottom: -1px;
  background: linear-gradient(45deg, 
    rgba(255, 255, 255, 0.1) 0%,
    rgba(255, 255, 255, 0.05) 50%,
    rgba(255, 255, 255, 0.1) 100%);
  border-radius: 16px;
  z-index: -1;
  opacity: 0.3;
}

/* KEEP YOUR STEALTH HOVER EFFECTS */
.stealth-mode .glass-container:hover {
  background: rgba(255, 255, 255, 0.03);
  border-color: rgba(255, 255, 255, 0.08);
  transform: scale(1.02);
}

/* KEEP YOUR EMERGENCY HIDE CLASSES */
.completely-hidden * {
  opacity: 0 !important;
  visibility: hidden !important;
  pointer-events: none !important;
}

.completely-hidden {
  opacity: 0 !important;
  visibility: hidden !important;
  pointer-events: none !important;
}

/* ENTRANCE ANIMATION */
@keyframes fadeInGlass {
  from { 
    opacity: 0; 
    transform: scale(0.95) translateY(10px);
    backdrop-filter: blur(0px);
  }
  to { 
    opacity: 1; 
    transform: scale(1) translateY(0);
    backdrop-filter: blur(20px);
  }
}

.glass-container {
  animation: fadeInGlass 0.4s cubic-bezier(0.4, 0, 0.2, 1);
}
